<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Canvas Test</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jaegerstein/kiwi@latest/dist/style/kiwi.min.css">
    <style>
        body {
            background-color: darkslategrey;
            overflow: hidden;
        }

        #canvas {
            background-color: darkslateblue;
        }
    </style>
    <script>
        const data = {
            "nodes": [
                {
                    "type": "text",
                    "text": "# ?",
                    "id": "c8709f08f5704f45",
                    "x": 320,
                    "y": -101,
                    "width": 60,
                    "height": 60,
                    "color": "2"
                },
                {
                    "id": "dea3f468124ad842",
                    "x": -1000,
                    "y": -41,
                    "width": 260,
                    "height": 126,
                    "color": "3",
                    "type": "text",
                    "text": "# Wo ist Peretin jetzt?"
                },
                {
                    "id": "63a155ee706799c0",
                    "x": -620,
                    "y": -172,
                    "width": 300,
                    "height": 143,
                    "color": "6",
                    "type": "text",
                    "text": "# Peretin ist in die Niedermark geflohen"
                },
                {
                    "id": "d53b42f321b98580",
                    "x": -158,
                    "y": -214,
                    "width": 318,
                    "height": 143,
                    "type": "file",
                    "file": "Journal/Questen/Besiegt den Nekromanten Peretin.md"
                },
                {
                    "id": "1fbdfaf23c2cdc25",
                    "x": 150,
                    "y": 160,
                    "width": 270,
                    "height": 160,
                    "color": "3",
                    "type": "text",
                    "text": "# Warum wurde Peretin Nekromant?"
                },
                {
                    "id": "832d43eccbb06c26",
                    "x": -319,
                    "y": 85,
                    "width": 260,
                    "height": 140,
                    "color": "3",
                    "type": "text",
                    "text": "# Wie wurde Peretin Nekromant?"
                },
                {
                    "id": "152cd496dd45cf2a",
                    "x": -59,
                    "y": 420,
                    "width": 60,
                    "height": 60,
                    "color": "2",
                    "type": "text",
                    "text": "# ?"
                }
            ],
            "edges": [
                {
                    "id": "0a3b53d112207a7d",
                    "fromNode": "d53b42f321b98580",
                    "fromSide": "bottom",
                    "toNode": "832d43eccbb06c26",
                    "toSide": "top"
                },
                {
                    "id": "c5bc0a465985cb50",
                    "fromNode": "d53b42f321b98580",
                    "fromSide": "bottom",
                    "toNode": "1fbdfaf23c2cdc25",
                    "toSide": "top"
                },
                {
                    "id": "7d51e2126e4e3e97",
                    "fromNode": "832d43eccbb06c26",
                    "fromSide": "bottom",
                    "toNode": "152cd496dd45cf2a",
                    "toSide": "left"
                },
                {
                    "id": "e2bbaebda75f9ea8",
                    "fromNode": "152cd496dd45cf2a",
                    "fromSide": "right",
                    "toNode": "1fbdfaf23c2cdc25",
                    "toSide": "bottom"
                },
                {
                    "id": "9152d4cf6ce7da1d",
                    "fromNode": "d53b42f321b98580",
                    "fromSide": "left",
                    "toNode": "63a155ee706799c0",
                    "toSide": "right"
                },
                {
                    "id": "a3f23c86986253fc",
                    "fromNode": "63a155ee706799c0",
                    "fromSide": "left",
                    "toNode": "dea3f468124ad842",
                    "toSide": "right"
                },
                {
                    "id": "8ba573e385b8765a",
                    "fromNode": "d53b42f321b98580",
                    "fromSide": "right",
                    "toNode": "c8709f08f5704f45",
                    "toSide": "left"
                }
            ]
        }
    </script>
</head>
<body class="kiwi">
<canvas id="canvas" class="viewport"></canvas>

<script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const cameraOffset = {x: window.innerWidth / 2, y: window.innerHeight / 2};
    const MAX_ZOOM = 5;
    const MIN_ZOOM = 0.1;
    const SCROLL_SENSITIVITY = .0005;

    let cameraZoom = 1;

    const nodePos = {};

    function draw() {
        // makes the canvas the size of the viewport
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Translate to the canvas centre before zooming - so you'll always zoom on what you're looking directly at
        ctx.translate(window.innerWidth / 2, window.innerHeight / 2);
        ctx.scale(cameraZoom, cameraZoom);
        ctx.translate(
            -window.innerWidth / 2 + cameraOffset.x,
            -window.innerHeight / 2 + cameraOffset.y
        );

        function drawData() {
            data.edges.forEach(edge => {
                const from = data.nodes.find(node => node.id === edge.fromNode);
                const to = data.nodes.find(node => node.id === edge.toNode);
                if (!from || !to) return;

                // Determine control points for Bezier curve
                const dx = (to.x + (to.width / 2)) - (from.x + (from.width / 2));
                const cp1x = from.x + (from.width / 2) + dx / 3;
                const cp1y = from.y + (from.height / 2);
                const cp2x = to.x + (to.width / 2) - dx / 3;
                const cp2y = to.y + (to.height / 2);

                // Draw Bezier curve
                ctx.beginPath();
                ctx.strokeStyle = '#000';
                ctx.moveTo(from.x + (from.width / 2), from.y + (from.height / 2));
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, to.x + (to.width / 2), to.y + (to.height / 2));
                ctx.stroke();
                ctx.closePath();
            });

            data.nodes.forEach(node => {
                ctx.beginPath();
                ctx.fillStyle = '#fff';
                ctx.fillRect(node.x, node.y, node.width, node.height);

                nodePos[node.id] = {
                    x: (node.x - cameraOffset.x / cameraZoom),
                    y: (node.y - cameraOffset.y / cameraZoom),
                    width: node.width / cameraZoom,
                    height: node.height / cameraZoom
                }

                ctx.fillStyle = '#000';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = '16px Calibri';
                ctx.fillText(node.text, node.x + node.width / 2, node.y + node.height / 2);
                ctx.closePath();
            });
        }

        drawData();
        requestAnimationFrame(draw);
    }

    // Gets the relevant location from a mouse or single touch event
    function getEventLocation(e) {
        if (e.touches && e.touches.length === 1) {
            return {x: e.touches[0].clientX, y: e.touches[0].clientY};
        } else if (e.clientX && e.clientY) {
            return {x: e.clientX, y: e.clientY};
        }
    }

    let isDragging = false;
    let dragStart = {x: 0, y: 0};

    function onPointerDown(e) {
        isDragging = true;
        dragStart.x = getEventLocation(e).x / cameraZoom - cameraOffset.x;
        dragStart.y = getEventLocation(e).y / cameraZoom - cameraOffset.y;
    }

    function onPointerUp(e) {
        isDragging = false;
        initialPinchDistance = null;
        lastZoom = cameraZoom;
    }

    function onPointerMove(e) {
        if (isDragging) {
            cameraOffset.x = getEventLocation(e).x / cameraZoom - dragStart.x;
            cameraOffset.y = getEventLocation(e).y / cameraZoom - dragStart.y;
        }

        const {clientX: x, clientY: y} = e;
        const mouseX = (x + window.innerWidth / 2) * cameraZoom - (window.innerWidth / 2 + cameraOffset.x);
        const mouseY = (y + window.innerHeight / 2) * cameraZoom - (window.innerHeight / 2 + cameraOffset.y);

        data.nodes.forEach(node => {
            const {x: nx, y: ny} = node;
            if (mouseX >= nx && mouseX <= nx + node.width &&
                mouseY >= ny && mouseY <= ny + node.height) {
                console.log(node.text);
            }
        });
    }

    function handleTouch(e, singleTouchHandler) {
        if (e.touches.length === 1) {
            singleTouchHandler(e);
        } else if (e.type === "touchmove" && e.touches.length === 2) {
            isDragging = false;
            handlePinch(e);
        }
    }

    let initialPinchDistance = null;
    let lastZoom = cameraZoom;

    function handlePinch(e) {
        e.preventDefault();

        let touch1 = {x: e.touches[0].clientX, y: e.touches[0].clientY};
        let touch2 = {x: e.touches[1].clientX, y: e.touches[1].clientY};

        // This is distance squared, but no need for an expensive sqrt as it's only used in ratio
        let currentDistance =
            (touch1.x - touch2.x) ** 2 + (touch1.y - touch2.y) ** 2;

        if (initialPinchDistance == null) {
            initialPinchDistance = currentDistance;
        } else {
            adjustZoom(null, currentDistance / initialPinchDistance);
        }
    }

    function adjustZoom(zoomAmount, zoomFactor) {
        if (!isDragging) {
            if (zoomAmount) {
                cameraZoom += zoomAmount;
            } else if (zoomFactor) {
                console.log(zoomFactor);
                cameraZoom = zoomFactor * lastZoom;
            }
            cameraZoom = Math.min(cameraZoom, MAX_ZOOM);
            cameraZoom = Math.max(cameraZoom, MIN_ZOOM);
        }
    }

    canvas.addEventListener("mousedown", onPointerDown);
    canvas.addEventListener("touchstart", (e) => handleTouch(e, onPointerDown));
    canvas.addEventListener("mouseup", onPointerUp);
    canvas.addEventListener("touchend", (e) => handleTouch(e, onPointerUp));
    canvas.addEventListener("mousemove", onPointerMove);
    canvas.addEventListener("touchmove", (e) => handleTouch(e, onPointerMove));
    canvas.addEventListener("wheel", (e) =>
        adjustZoom(e.deltaY * SCROLL_SENSITIVITY)
    );

    // Ready, set, go
    draw();
</script>
</body>
</html>